= Урок 1: Статический анализ кода в Swift
:sectnums:
:source-highlighter: highlight.js

== Цели урока

* Понять, что такое статический анализ и зачем он нужен.
* Познакомиться с основными инструментами статического анализа в Swift: SwiftLint и Clang Static Analyzer.
* Узнать, как интегрировать статический анализ в процесс разработки и CI/CD.

---

== Теория

=== Что такое статический анализ?

*Статический анализ кода* — это процесс проверки исходного кода программы без её фактического выполнения (в отличие от динамического анализа, который происходит во время работы приложения). Анализаторы "читают" ваш код и ищут в нём потенциальные проблемы, ошибки, уязвимости и несоответствия стилю кодирования.

Это как если бы очень педантичный и опытный программист просматривал ваш код и давал свои замечания ещё до того, как вы попытаетесь его скомпилировать и запустить.

=== Зачем нужен статический анализ?

1.  **Раннее обнаружение ошибок:** Находит баги, которые могут быть не видны при обычном тестировании, например, утечки памяти, "мертвый" код (который никогда не выполнится), или потенциальное разыменование `nil`.
2.  **Соблюдение единого стиля кода (Code Style):** В командной работе критически важно, чтобы все писали код в одном стиле. Статический анализ автоматически следит за соблюдением правил форматирования, именования и т.д.
3.  **Повышение читаемости и поддерживаемости:** Код, написанный по общим правилам, легче читать и понимать другим разработчикам (и вам самим через полгода).
4.  **Автоматизация ревью:** Снимает с код-ревьюера рутинную задачу по вылавливанию опечаток и проблем со стилем, позволяя ему сконцентрироваться на логике и архитектуре.

=== Как работают анализаторы?

Хотя это сложная тема, базовый принцип работы большинства статических анализаторов можно разбить на несколько шагов:

1.  **Парсинг (Parsing):** Анализатор читает ваш исходный код и преобразует его в структуру данных, понятную для машины. Чаще всего это **Абстрактное синтаксическое дерево (Abstract Syntax Tree, AST)**. AST представляет собой древовидную структуру кода, где каждый узел — это оператор, переменная или выражение.
2.  **Построение графов:** На основе AST строятся более сложные модели, такие как **Граф потока управления (Control Flow Graph, CFG)**. Этот граф показывает все возможные пути выполнения вашей программы.
3.  **Анализ потока данных (Data Flow Analysis):** Анализатор "проходит" по графу потока управления и отслеживает состояние переменных. Например, он может определить, была ли переменная инициализирована перед использованием или может ли она быть `nil` в определенной точке.
4.  **Применение правил:** Наконец, анализатор применяет к построенным моделям свой набор правил.
    *   **Линтеры (как SwiftLint)** в основном работают с AST, проверяя структуру кода на соответствие правилам стиля (например, "длина строки не более 120 символов" или "имя константы должно быть в `camelCase`").
    *   **Более мощные анализаторы (как Clang Analyzer)** используют CFG и анализ потока данных для поиска сложных логических ошибок (например, "эта переменная может быть `nil`, и здесь происходит ее принудительное разыменование, что приведет к крешу").

Понимание этих шагов помогает осознать, почему анализаторы могут находить одни ошибки, но пропускать другие, и почему некоторые правила (особенно в Clang) могут казаться "магическими".

=== Основные инструменты в Swift

==== 1. SwiftLint

*   **Что это:** Самый популярный *линтер* для Swift. Линтер — это инструмент, который проверяет код на соответствие определённому набору правил стиля и "хорошего тона".
*   **Что проверяет:** Длину строк, именование переменных, лишние пробелы, сложность функций и сотни других правил.
*   **Как настраивается:** Через файл `.swiftlint.yml` в корне проекта, где можно включать/выключать правила и задавать их параметры.
*   **Как используется:**
    *   **В Xcode:** Добавляется как "Build Phase Script", чтобы вы видели предупреждения и ошибки прямо в редакторе во время компиляции.
    *   **В CI/CD:** Запускается как отдельный шаг в пайплайне. Если найдены критические нарушения, пайплайн падает, не давая "грязному" коду попасть в основную ветку.

==== Пример файла `.swiftlint.yml`

Вот пример базовой конфигурации, которую можно положить в корень проекта:

[source,yaml]
----
# Правила, которые мы отключаем
disabled_rules:
  - trailing_whitespace
  - identifier_name

# Правила, которые не включены по умолчанию, но мы хотим их использовать
opt_in_rules:
  - empty_count # Рекомендует `isEmpty` вместо `count == 0`
  - force_unwrapping # Запрещает принудительное разворачивание `!`

# Настройка конкретных правил
line_length:
  warning: 120
  error: 150

file_length:
  warning: 500
  error: 800

# Исключаем из анализа директории с зависимостями
excluded:
  - Pods
----

*   `disabled_rules`: Список правил, которые не будут применяться.
*   `opt_in_rules`: Список дополнительных, более строгих правил, которые нужно включить явно.
*   `line_length`, `file_length`: Настройка пороговых значений для конкретных правил. Здесь `warning` покажет предупреждение, а `error` — ошибку, которая может "уронить" сборку.
*   `excluded`: Список файлов и директорий, которые SwiftLint будет игнорировать.

==== 2. Clang Static Analyzer

*   **Что это:** Мощный анализатор, встроенный прямо в Xcode. Он является частью компилятора Clang.
*   **Что проверяет:** Более глубокие и сложные проблемы, связанные с логикой и управлением памятью. Например:
    *   Утечки памяти (Memory Leaks).
    *   Разыменование нулевого указателя (Null pointer dereferencing).
    *   Неиспользуемый код (Dead code).
    *   Логические ошибки (например, условие, которое всегда истинно или ложно).
*   **Как используется:**
    *   Запускается из Xcode через меню `Product` -> `Analyze` (или `Shift+Cmd+B`).
    *   Результаты отображаются в "Issue Navigator" с подробным описанием шагов, которые приводят к ошибке.

=== Сравнение SwiftLint и Clang Analyzer

| Характеристика | SwiftLint | Clang Static Analyzer |
| :--- | :--- | :--- |
| **Основная цель** | Стиль кода и лучшие практики | Поиск багов и утечек памяти |
| **Глубина анализа** | Поверхностный (синтаксис, стиль) | Глубокий (потоки данных, логика) |
| **Настройка** | Гибкая, через `.swiftlint.yml` | Встроен в Xcode, почти не настраивается |
| **Запуск** | Вручную, в Build Phase, в CI | Вручную из Xcode (`Product > Analyze`) |

**Вывод:** Эти инструменты не заменяют, а **дополняют** друг друга. SwiftLint поддерживает чистоту и читаемость кода, а Clang Analyzer помогает находить скрытые логические ошибки. В нашем проекте мы будем активно использовать оба.