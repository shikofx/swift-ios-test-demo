= Урок 2: Инструменты статического анализа в Swift
:sectnums:
:source-highlighter: highlight.js

== Цели урока

* Познакомиться с основными инструментами статического анализа в Swift: SwiftLint и Clang Static Analyzer.
* Научиться настраивать SwiftLint с помощью файла `.swiftlint.yml`.
* Понять различия, сильные и слабые стороны каждого инструмента.

---

== Теория

В экосистеме Swift есть два основных инструмента для статического анализа, которые решают разные, но одинаково важные задачи.

=== SwiftLint

*   **Что это:** Самый популярный *линтер* для Swift. Линтер — это инструмент, который проверяет код на соответствие определённому набору правил стиля и "хорошего тона".
*   **Что проверяет:** Длину строк, именование переменных, лишние пробелы, сложность функций и сотни других правил.
*   **Как настраивается:** Через файл `.swiftlint.yml` в корне проекта, где можно включать/выключать правила и задавать их параметры.
*   **Как используется:**
    *   **В Xcode:** Добавляется как "Build Phase Script", чтобы вы видели предупреждения и ошибки прямо в редакторе во время компиляции.
    *   **В CI/CD:** Запускается как отдельный шаг в пайплайне. Если найдены критические нарушения, пайплайн падает, не давая "грязному" коду попасть в основную ветку.

==== Пример файла `.swiftlint.yml`

Вот пример базовой конфигурации, которую можно положить в корень проекта:

[source,yaml]
----
# Правила, которые мы отключаем
disabled_rules:
  - trailing_whitespace
  - identifier_name

# Правила, которые не включены по умолчанию, но мы хотим их использовать
opt_in_rules:
  - empty_count # Рекомендует `isEmpty` вместо `count == 0`
  - force_unwrapping # Запрещает принудительное разворачивание `!`

# Настройка конкретных правил
line_length:
  warning: 120
  error: 150

file_length:
  warning: 500
  error: 800

# Исключаем из анализа директории с зависимостями
excluded:
  - Pods
----

*   `disabled_rules`: Список правил, которые не будут применяться.
*   `opt_in_rules`: Список дополнительных, более строгих правил, которые нужно включить явно.
*   `line_length`, `file_length`: Настройка пороговых значений для конкретных правил. Здесь `warning` покажет предупреждение, а `error` — ошибку, которая может "уронить" сборку.
*   `excluded`: Список файлов и директорий, которые SwiftLint будет игнорировать.

=== Clang Static Analyzer

*   **Что это:** Мощный анализатор, встроенный прямо в Xcode. Он является частью компилятора Clang.
*   **Что проверяет:** Более глубокие и сложные проблемы, связанные с логикой и управлением памятью. Например:
    *   Утечки памяти (Memory Leaks).
    *   Разыменование нулевого указателя (Null pointer dereferencing).
    *   Неиспользуемый код (Dead code).
    *   Логические ошибки (например, условие, которое всегда истинно или ложно).
*   **Как используется:**
    *   Запускается из Xcode через меню `Product` -> `Analyze` (или `Shift+Cmd+B`).
    *   Результаты отображаются в "Issue Navigator" с подробным описанием шагов, которые приводят к ошибке.

=== Сравнение SwiftLint и Clang Analyzer

| Характеристика | SwiftLint | Clang Static Analyzer |
| :--- | :--- | :--- |
| **Основная цель** | Стиль кода и лучшие практики | Поиск багов и утечек памяти |
| **Глубина анализа** | Поверхностный (синтаксис, стиль) | Глубокий (потоки данных, логика) |
| **Настройка** | Гибкая, через `.swiftlint.yml` | Встроен в Xcode, почти не настраивается |
| **Запуск** | Вручную, в Build Phase, в CI | Вручную из Xcode (`Product > Analyze`), в CI |

**Вывод:** Эти инструменты не заменяют, а **дополняют** друг друга. SwiftLint поддерживает чистоту и читаемость кода, а Clang Analyzer помогает находить скрытые логические ошибки. В нашем проекте мы будем активно использовать оба.