= Урок 1: Наш первый CI/CD пайплайн на GitHub Actions
:sectnums:
:source-highlighter: highlight.js

== Цели урока

* Понять структуру базового workflow GitHub Actions.
* Разобрать назначение каждого блока в файле `ios-ci.yml`.
* Узнать, как запускается CI/CD пайплайн и что он делает.

---

== Теория

В этом уроке мы рассмотрим наш первый CI/CD пайплайн, определенный в файле `.github/workflows/ios-ci.yml`. Этот пайплайн является отправной точкой для автоматизации сборки и тестирования нашего iOS-приложения.

[source,yaml]
----
name: SDET-IOS-DEMO CI

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - main

jobs:
  test:
    name: Build and Analyze
    runs-on: macos-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check Xcode version
        run: xcodebuild -version
        
      - name: Install SwiftLint
        run: brew install swiftlint

      - name: Run SwiftLint
        run: swiftlint --strict

      - name: Run Clang Static Analyzer
        run: xcodebuild analyze -scheme "swift-ios-test-demo" -destination 'platform=iOS Simulator,name=iPhone 15'
----

Давайте разберем этот файл по частям:

=== `name: SDET-IOS-DEMO CI`

Это просто имя вашего workflow. Оно будет отображаться в интерфейсе GitHub Actions и помогает быстро понять, что делает этот пайплайн.

=== `on:` - Триггеры запуска Workflow

Секция `on:` определяет, когда этот workflow будет запускаться. В нашем случае он настроен на два типа событий:

*   `push:`: Workflow запустится при каждом `push` (отправке изменений) в *любую* ветку (`'**'`). Это полезно для быстрой обратной связи по изменениям.
*   `pull_request:`: Workflow запустится при создании или обновлении `pull request` (запроса на слияние) в ветку `main`. Это критично для проверки кода перед его слиянием в основную ветку.

=== `jobs:` - Задачи Workflow

Workflow состоит из одной или нескольких задач (`jobs`). Каждая задача выполняется на отдельном виртуальном окружении. По умолчанию, задачи выполняются параллельно, если не указана зависимость (`needs`). В нашем текущем пайплайне определены две задачи: `swiftlint_analysis` и `clang_analysis`.

==== `swiftlint_analysis:` - Задача "Run SwiftLint"

*   `name: Run SwiftLint`: Имя этой конкретной задачи.
*   `runs-on: macos-latest`: Указывает, на каком типе виртуальной машины будет выполняться эта задача. Для iOS-разработки всегда требуется `macos-latest` (или другая версия macOS), так как только на macOS доступны Xcode и iOS SDK.

==== `steps:` - Шаги задачи

Каждая задача состоит из последовательности шагов (`steps`), которые выполняются по порядку.

*   `- name: Checkout code`:
    *   `uses: actions/checkout@v4`: Этот шаг использует стандартный GitHub Action `checkout` версии 4. Он клонирует ваш репозиторий на виртуальную машину, чтобы последующие шаги могли работать с вашим кодом. Это почти всегда первый шаг в любом CI/CD пайплайне.

*   `- name: Check Xcode version`:
    *   `run: xcodebuild -version`: Этот шаг выполняет команду в терминале виртуальной машины. Здесь мы просто проверяем версию Xcode, установленную на ранере. Это полезно для отладки и убеждения, что используется ожидаемая версия Xcode.

=== Что дальше?
*   `- name: Install SwiftLint` (в задаче `swiftlint_analysis`):
    *   `run: brew install swiftlint`: Этот шаг использует менеджер пакетов Homebrew (стандарт для macOS) для установки SwiftLint на виртуальную машину.

*   `- name: Run SwiftLint` (в задаче `swiftlint_analysis`):
    *   `run: swiftlint --strict`: Этот шаг запускает сам анализатор. Мы используем флаг `--strict`, который заставляет команду завершиться с ошибкой (и "уронить" пайплайн), если найдено хотя бы одно предупреждение (`warning`) или ошибка (`error`). Это гарантирует, что код, не соответствующий правилам, не попадет в основную ветку.

==== `clang_analysis:` - Задача "Run Clang Static Analyzer"

*   `name: Run Clang Static Analyzer`: Имя этой конкретной задачи.
*   `runs-on: macos-latest`: Аналогично, эта задача также требует macOS-раннер.

*   `- name: Checkout code` (в задаче `clang_analysis`):
    *   `uses: actions/checkout@v4`: Каждая задача должна клонировать репозиторий, чтобы иметь доступ к исходному коду.

*   `- name: Run Clang Static Analyzer` (в задаче `clang_analysis`):
    *   `run: xcodebuild analyze ...`: Этот шаг запускает встроенный в Xcode статический анализатор Clang.
    *   `-scheme "swift-ios-test-demo"`: Указывает, какую схему проекта анализировать.
    *   `-destination '...'`: Определяет, для какой цели (симулятора) будет проводиться анализ. Это необходимо, так как настройки сборки могут отличаться для разных платформ.
    *   Если анализатор найдет серьезные проблемы (потенциальные утечки памяти, логические ошибки), `xcodebuild` завершится с ошибкой, и пайплайн также упадет.

=== Что дальше?

Теперь наш пайплайн выполняет статический анализ кода **параллельно**, что значительно ускоряет обратную связь. `SwiftLint` проверяет стиль, а `Clang Static Analyzer` ищет потенциальные баги.

На следующих этапах мы будем расширять его, добавляя шаги для:

*   Установки зависимостей.
*   Сборки приложения.
*   Запуска Unit- и UI-тестов.
*   Сохранения артефактов.